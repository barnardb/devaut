#!/usr/bin/env bash
# personal build script

set -e
set -u

usage() {
    echo "usage: push [--all-at-once | --dry-run | --if-needed | --no-fetch]... [<commit-ish>]"
}

show_help() {
    usage
    cat <<"EOF"

`push` helps you get all of your amazing commits pushed upstream, without
letting obvious accidents slip through.

It will validate and push commits that haven't yet been pushed upstream.
Commits are validated by running them in a shadow worktree using
[git-new-workdir], so that you can keep on working while the build is running.

The current branch is pushed by default, or you can specify the commit-ish
(branch, commit, HEAD, â€¦) to use.

The first step is a check to make sure you have a fast-forward commit.  To
ensure we have the current remote state, this is preceeded by a call to `git
fetch` unless disabled with the `--no-fetch` flag.

Each commit is validated and pushed individually, or you can `push
--all-at-once`.

Use `--dry-run` to do everything *except* the final push.  This is a convenient
way to validate commits in a clean environment without pushing.

You'll get an error message and non-zero exit status if there's nothing to
push, but you can `push --if-needed` to have your shell keep its cool.

Happy pushing :)


##### Dependencies

* [git-new-workdir]


[git-new-workdir]: https://github.com/git/git/blob/master/contrib/workdir/git-new-workdir
EOF
}

all_at_once=false
dry_run=false
if_needed=false
perform_fetch=true

while (( $# > 0 )); do
    case "$1" in
        --all-at-once) all_at_once=true;;
        --dry-run) dry_run=true;;
        --if-needed) if_needed=true;;
        --no-fetch) perform_fetch=false;;
        -'?' | --help) show_help; exit 0;;
        --) shift; break;;
        -*) { echo "Error: unexpected option $1"; usage; echo; echo "Use -? or --help for help, or -- to separate arguments from options"; } >&2; exit 1;;
        *) break;;
    esac
    shift
done

if [ $# -gt 1 ]; then
    usage >&2
    exit 1
fi

cd "$(git rev-parse --show-toplevel)"

if [ "${dry_run}" = "true" ]; then
    echo "This is a DRY RUN: Nothing will actually be pushed"
fi

to_push="$(git rev-parse "${1-HEAD}")"
echo "Last commit to push ${to_push}"

if [ "${perform_fetch}" == true ]; then
    git fetch
fi

upstream="$(git rev-parse --abbrev-ref --symbolic-full-name @{upstream})"
remote="${upstream%/*}"
remote_branch="${upstream#*/}"
[ "${remote}/${remote_branch}" = "${upstream}" ] || {
    echo "Remote ${remote} and branch ${remote_branch} do not add up to upstream ${upstream}" >&2
    exit 1
}
echo "Found upstream ${upstream} on remote ${remote}"

upstream_commit="$(git rev-parse "${upstream}")"
echo "upstream ${upstream} is at ${upstream_commit}"
if [ "${to_push}" = "${upstream_commit}" ]; then
    case "${if_needed}" in
        true)
            echo "Nothing to push."
            exit
            ;;
        *)
            echo "Error: commit to push is the same as upstream ${upstream}. Nothing to push." >&2
            exit 1
            ;;
    esac
fi

merge_base="$(git merge-base "${to_push}" "${upstream_commit}")"
if [ "${merge_base}" != "${upstream_commit}" ]; then
    echo "Error: merge-base is ${merge_base}, which is not the same as upstream ${upstream}. Please rebase." >&2
    exit 1
fi

if [ "${all_at_once}" = false ]; then
    to_push=($(git rev-list --reverse "${upstream_commit}..${to_push}"))
    echo "Total of ${#to_push[@]} commits to push:"
    printf "%s\n" "${to_push[@]}"
fi

original_dir="$PWD"
workdir="$(dirname "${original_dir}")/.$(basename "${original_dir}")-workdir"
[ -e "${workdir}" ] || {
    echo "Creating new shadow working directory ${workdir}"
    /usr/local/share/git-core/contrib/workdir/git-new-workdir "${original_dir}" "${workdir}" "${to_push}"
}

echo "Moving to shadow working directory ${workdir}"
cd "${workdir}"

for commit in "${to_push[@]}"; do
    echo "Preparing to validate and push $commit"
    git reset --hard "${commit}"
    git clean -fxd

    link_exclusions=()
    for path in .cache cache go; do
        original="${original_dir}/${path}"
        if ! [ -e "${path}" ] && [ -e "${original}" ]; then
            echo "Linking ${path} to ${original}"
            ln -s "${original}" "${path}"
            link_exclusions+=(--exclude "${path}")
        fi
    done

    echo "Building the project"
    if [ -e go.sh ]; then
        echo "I recommend that you do:" >&2
        echo "    mv go.sh go" >&2
        exit 1
    elif [ -e go ]; then
        ./go
    elif [ -e pre-commit.sh ]; then
        ./pre-commit.sh
    elif [ -e build/sbt ]; then
        ./build/sbt +clean +test +package
    elif [ -e *.sbt ] || [ -e project/*.sbt ] || [ -e project/*.scala ]; then
        sbt +clean +test +package
    else
        echo "Couldn't find a runner for this project" >&2
        exit 1
    fi

    if [ -n "$(set +u && git ls-files --modified --others --exclude-standard "${link_exclusions[@]}")" ]; then
        echo
        echo "ERROR: Unstaged changes after a successful build run!" >&2
        git status
        exit 1
    fi

    echo "$commit validated; pushing"
    if [ "${dry_run}" = true ]; then
        echo "Skipping push due to DRY RUN"
    else
        git push "${remote}" "${commit}:${remote_branch}"
    fi
done

if [ "${dry_run}" = true ]; then
    result="would have pushed (but for DRY RUN)"
else
    result="pushed"
fi
echo "SUCCESS: ${result} ${to_push} to ${upstream}"
